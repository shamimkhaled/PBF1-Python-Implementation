# -*- coding: utf-8 -*-
"""updated-PBF1-code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BpFq61Nwmad6fiyISYpL3yJliBQMeszC
"""

!pip install testcase

!pip install mmh3

import mmh3 as mmh3

import numpy as np

!pip install bitsets
from bitsets import bitset

#!/usr/bin/env python
# package: edu.ecnu.pbf


# 
#  * Unit test for simple App.
# \
import testcase 
import unittest
class AppTest(unittest.TestCase):
   
    def __init__(self, testName):
        """ generated source for method __init__ """
        super(AppTest, self).__init__(testName)

    def suite(cls):
        """ generated source for method suite """
        return TestSuite(AppTest.__class__)
     
    def testApp(self):
        """ generated source for method testApp """
        assertTrue(True)



class DualTuple:
	def __init__(self, first, second):
		self.first = first
		self.second = second
	
	def getFirst(self):
		return self.first
	
	def getSecond(self):
		return self.second
	
	def toString(self):
		return "(" + self.first + ","  + self.second + ")"

from abc import ABCMeta, abstractmethod

class PersistentBloomFilter(object):
    def insertString(self, element, timestamp):
        pass

    def queryString(self, element, timestamp):
        pass

    def queryString(self, element, startTime, endTime):
        pass

    def insert(self, element, timestamp):
        pass

    def query(self, element, timestamp):
        pass

    def query(self, element, startTime, endTime):
        pass

!pip install bitarray

from bitarray import bitarray

!pip install bitset

from collections import Sequence
import math

class BitSet(Sequence):

    value = 0
    length = 0

    def from_sequence(cls, seq):
        n = 0
        for index, value in enumerate(reversed(seq)):
            n += 2**index * bool(int(value))
        b = Bitset(n)
        return b

    def __init__(self, value=0, length=0):
        """Creates a Bitset with the given integer value."""
        self.value = value
        try: self.length = length or math.floor(math.log(value, 2)) + 1
        except Exception: self.length = 0

    def __and__(self, other):
        b = Bitset(self.value & int(other))
        b.length = max((self.length, b.length))
        return b

    def __or__(self, other):
        b = Bitset(self.value | int(other))
        b.length = max((self.length, b.length))
        return b

    def __invert__(self):
        b = Bitset(~self.value)
        b.length = max((self.length, b.length))
        return b

    def __xor__(self, value):
        b = Bitset(self.value ^ int(value))
        b.length = max((self.length, b.length))
        return b

    def __lshift__(self, value):
        b = Bitset(self.value << int(value))
        b.length = max((self.length, b.length))
        return b

    def __rshift__(self, value):
        b = Bitset(self.value >> int(value))
        b.length = max((self.length, b.length))
        return b

    def __eq__(self, other):
        try:
            return self.value == other.value
        except Exception:
            return self.value == other

    def __int__(self):
        return self.value

    def __str__(self):
        s = ""
        for i in self[:]:
            s += "1" if i else "0"
        return s

    def __repr__(self):
        return "Bitset(%s)" % str(self)

    def __getitem__(self, s):
        """Gets the specified position.

        Like normal integers, 0 represents the MSB.
        """
        try:
            start, stop, step = s.indices(len(self))
            a = []
            for x in y:
                a.append(x)
            results =np.array(a)
            for position in range(start, stop, step):
                pos = len(self) - position - 1
                results.append(bool(self.value & (int(np.left_shift(1,pos)))))
            return results
        except:
            pos = len(self) - s - 1
            return bool(self.value & (int(np.left_shift(1,pos))))

    def __setitem__(self, s, value):
        """Sets the specified position/s to value.

        Like normal integers, 0 represents the MSB.
        """
        try:
            start, stop, step = s.indices(len(self))
            for position in range(start, stop, step):
                pos = len(self) - position - 1
                if value: self.value |= (int(np.left_shift(1,pos)))
                else: self.value &= ~(int(np.left_shift(1,pos)))
            maximum_position = max((start + 1, stop, len(self)))
            self.length = maximum_position
        except:
            pos = len(self) - s - 1
            if value: self.value |= (int(np.left_shift(1,pos)))
            else: self.value &= ~(int(np.left_shift(1,pos)))
            if len(self) < pos: self.length = pos
        return self

    def __iter__(self):
        """Iterates over the values in the bitset."""
        for i in self[:]:
            yield i

    def __len__(self):
        """Returns the length of the bitset."""
        return self.length

class Beta0:
    #def __init__(self):
        #self.bitNum = 1000000
        #self.hashNum = 4
        #self.bs = bitarray(self.bitNum)
        
    def __init__(self, bitNum=1000000, hashNum= 4):
        self.bitNum = bitNum
        self.hashNum = hashNum
        self.bs = bitarray(bitNum)
    
    def getBitSet(self):
       
        return self.bs

    def setBitSet(self, bs):
        
        self.bs = bs

 
    def getSize(self):
        
        return self.bitNum

   
    def getHashNum(self):
        
        return self.hashNum

    
    def insertString(self, element, timestamp):
        result = True
        byteElement = element.encode('utf-8')
        for i in range(0, self.hashNum):
            hash1 = mmh3.hash(byteElement, int(timestamp * self.hashNum + i))
            index = self.getIndex(hash1)
            self.bs.set(index)

        return result

    
    def queryString(self, element, timestamp):
        byteElement = bytearray(element.encode('utf-8'))
        isExist = True
        for i in range(self.hashNum):
            hash1 = mmh3.hash(byteElement, int(timestamp * self.hashNum + i))
            index = self.getIndex(hash1)
            if not self.bs[index]:
                isExist = False
                break
        return isExist

    
    def queryString(self, element, startTime, endTime):
        isExist = False

        if startTime > endTime or startTime < 0 or endTime < 0:
            isExist = False
        else:
            for i in range(startTime, endTime + 1):
                if self.queryString(element, i):
                    isExist = True
                    break

        return isExist

    
    def insert(self, element, timestamp):
        result = True
        for i in range(self.hashNum):
            hash = mmh3.hash(element, (int)(timestamp * self.hashNum + i))
            index = self.getIndex(hash)
            self.bs[index] = 1
        return result

   
  
    def query0(self, element, timestamp):
        result = True
        for i in range(0, self.hashNum):
            hash1 = mmh3.hash(element, int(timestamp * self.hashNum + i))
            index = self.getIndex(hash1)
            if not self.bs[index]:
                result = False
                break
        return result

    
    #@query.register(object, byte, long, long)
    def query(self, element, startTime, endTime):
        result = False
        if startTime > endTime or endTime < 0:
            result = False
        else:
            startTime = startTime if startTime > 0 else 0
            for i in range(startTime, endTime+1):
                if self.query0(element, i):
                    result = True
                    break
        return result

    def getIndex(self, hash1):
        
        index = hash1 % self.bitNum
        return index if index >= 0 else -index

def main():
        element = "guo".encode()
        b = Beta0(100000, 6)
        b.insert(element, 100)
        print(b.query0(element, 100))
        print(b.query(element, 0, 99))
        print(b.query(element, 101, 200))
        print(b.query(element, 0, 100))
        print(b.query(element, 100, 200))
        print(b.query(element, 0, 200))
        print(b.query(element, 200, 215))
    
    if __name__ == "__main__":
        main()

import array

class BinaryUtil2:
    bitMask = array.array('I', [0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8,
                           0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80, 0xffffff00,
                           0xfffffe00, 0xfffffc00, 0xfffff800, 0xfffff000, 0xffffe000,
                           0xffffc000, 0xffff8000, 0xffff0000, 0xfffe0000, 0xfffc0000,
                           0xfff80000, 0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,
                           0xff000000, 0xfe000000, 0xfc000000, 0xf8000000, 0xf0000000,
                           0xe0000000, 0xc0000000, 0x80000000, 0x00000000])
    levelSize = [0, 1 << 0, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7, 1 << 8, 1 << 9, 1 << 10, 1 << 11, 1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16, 1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 21, 1 << 22, 1 << 23, 1 << 24, 1 << 25, 1 << 26, 1 << 27, 1 << 28, 1 << 29, 1 << 30 ]
    #bitMask = [ 0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8, 0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80, 0xffffff00, 0xfffffe00, 0xfffffc00, 0xfffff800, 0xfffff000, 0xffffe000, 0xffffc000, 0xffff8000, 0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000, 0xfff00000, 0xffe00000, 0xffc00000, 0xff800000, 0xff000000, 0xfe000000, 0xfc000000, 0xf8000000, 0xf0000000, 0xe0000000, 0xc0000000, 0x80000000, 0x00000000 ]
    #levelSize = [ 0, 1 << 0, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7, 1 << 8, 1 << 9, 1 << 10, 1 << 11, 1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16, 1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 21, 1 << 22, 1 << 23, 1 << 24, 1 << 25, 1 << 26, 1 << 27, 1 << 28, 1 << 29, 1 << 30 ]

    def getBinaryDecomposition(start, end):
        result = []
        i = start
        while i <= end:
            level = BinaryUtil2.getBinaryLevel(i, end)
            result.append(DualTuple(i, level))
            #print(result)
            i = i + (np.left_shift(1, (level - 1)))
        return result
      
  



    def getBinaryLevel(startKey, endKey):
        level = 1
        if startKey == endKey:
            level = 1
        elif 0 == startKey:
            size = endKey - startKey + 1
            start = 1
            end = 31
            middle = (start + end) / 2
            middle = int(middle)
            
            while start < end:
                middle = (start + end) / 2
                middle = int(middle)
                if BinaryUtil2.levelSize[middle] == size:
                    break
                elif BinaryUtil2.levelSize[middle] < size:
                    start = middle + 1
                else:
                    end = middle
            if BinaryUtil2.levelSize[middle] > size:
                level = middle - 1
            else:
                level = middle
        else:
            start = 1
            end = 32
            middle = (start + end) / 2
            middle = int(middle)
            while start < end:
                if 0 == (startKey & ~BinaryUtil2.bitMask[int(middle)]):
                    start = middle + 1
                else:
                    end = middle
                middle = (start + end) / 2
            level = int(middle)
            while (startKey + int(np.left_shift(1, level-1))) > (endKey + 1):
                level -= 1
        return level
    def getStartKey(startTime, endTime, level):
        a = []
        for x in BinaryUtil2.y:
            a.append(x)
        startKey = np.array(a)
        if 30 < level or 0 > level:
            pass
        else:
            i = startTime / BinaryUtil2.levelSize[level + 1]
            startKeyTemp = i * BinaryUtil2.levelSize[level + 1]
            while startKeyTemp <= endTime:
                startKey.append(startKeyTemp)
                startKeyTemp += BinaryUtil2.levelSize[level + 1]
        return startKey

def main():
    list1 = BinaryUtil2.getBinaryDecomposition (0, 16)
    #print(list1)
    #print("jk")
    for i in list1:
        print(str(i.getFirst()) + ": " + str(i.getSecond()))
        #print("jk")

if __name__ == "__main__":
    main()



import hashlib

class BasicBloomFilter:
    
    def __init__(self, bitNum=100000, hashNum=4):
        self.bitNum = bitNum
        self.hashNum = hashNum
        self.bs = bitarray(self.bitNum)
        
    def getBitSet(self):
        return self.bs
    
    def setBitSet(self, bs):
        self.bs = bs
        
    def get_size(self):
        return self.bitNum
    
    def getHashNum(self):
        return self.hashNum
    
    
        
        
    def insert(self, element):
        for i in range(0, self.hashNum):
            hash1 = mmh3.hash(element, i)
            index = self.getIndex(hash1)
            self.bs.__setitem__(index, True)
            
            
    
    def insertString(self, element):
        byteElement = bytearray(element, 'utf-8')

        for i in range(self.hashNum):
            hash1 =mmh3.hash(byteElement, i)
            index = self.getIndex(hash1)
            self.bs.__setitem__(index, True)
    
    def query(self, element):
        isExist = True
        for i in range(self.hashNum):
            hash1 = mmh3.hash(element, i)
            index = self.getIndex(hash1)
            if False == self.bs[index]:
                isExist = False
                break

        return isExist
                
    
    def queryString(self, element):
        byteElement = bytearray(element)
        isExist = True
        for i in range(0, self.hashNum):
            hash1 = mmh3.hash(byteElement, i)
            index = self.getIndex(hash1)
            if not self.bs[index]:
                isExist = False
            break
        return isExist

    
            
    
    def getPFP(self, insertNum):
        return self.decimal.ONE
        
    def getIndex(self,hash1):
        index = hash1 % self.bitNum
        return index if index >= 0 else -index

def main():
      bbf = BasicBloomFilter(100000, 5)
      bbf.insert("guo".encode())
      print(bbf.query("guo".encode()))
      print(bbf.query("g".encode()))

    if __name__ == "__main__":
      main()



class CommonConstants(object):
    g = [1 << 0, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7, 1 << 8, 1 << 9, 1 << 10, 1 << 11, 1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16, 1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 21, 1 << 22, 1 << 23, 1 << 24, 1 << 25, 1 << 26, 1 << 27, 1 << 28, 1 << 29, 1 << 30]
    K_MAX = 16
    MAX_LEVEL_NUM = 30

from collections import defaultdict

class Beta1(PersistentBloomFilter):
    
    def __init__(self, bitNum, levelNum, g):
        self.b0 = Beta0(bitNum, CommonConstants.K_MAX)
        self.totalBitNum = bitNum   
        self.gLevel = 1
        tempG = g
        tempG = tempG / 2
        tempG = int(tempG)
        while (tempG  > 0):
            tempG = int(tempG / 2)
            self.gLevel += 1
            
        
        self.bfArray = []
        j = 2
        self.bitNumTmp = bitNum
        #i = 0
        #print(self.gLevel)
        #for i = 0; i < (1 << (levelNum - self.gLevel + 1))-1; i++:
        #while (i < (1 << int(np.left_shift(1,(levelNum - self.gLevel + 1))) - 1)):   
        for i in range(0, int(np.left_shift(1,(levelNum - self.gLevel + 1))) - 1):
            self.bfArray.append(BasicBloomFilter(self.bitNumTmp, CommonConstants.K_MAX))
            self.totalBitNum += self.bitNumTmp
            
        
        self.levelNum = levelNum
        self.g = g
        self.maxT = CommonConstants.g[levelNum - 1] - 1
        
    def __init(self, m, k, levelNum, g):
        self.gLevel = 1
        tempG = g
        tempG = int(tempG / 2)
        while (tempG / 2) > 0:
            self.gLevel += 1
            
        self.b0 = Beta0(m[0], k[0])
        self.totalBitNum = m[0]
        self.bfArray = []
        for i in range(1, len(m)):
            if m[i] == 0:
                self.bfArray.append(BasicBloomFilter(1, 1))
            else:
                self.bfArray.append(BasicBloomFilter(m[i], k[i]))
                self.totalBitNum += m[i]
                
        self.levelNum = levelNum
        self.g = g
        self.maxT = CommonConstants.g[levelNum - 1] - 1
        
    def insertString(self, element, timestamp):
        index = 1
        start = 0
        end = self.maxT
        for i in range(0, self.levelNum - self.gLevel + 1):
            self.bfArray.get(index - 1).insertString(element)
            mid = (start + end) / 2
            mid = int(mid)
            if mid < timestamp:
                start = mid + 1 
                index = index * 2 + 1
            else:
                end = mid
                index = index * 2
                
        self.b0.insertString(element, timestamp)
        return True
    

   

    def queryString(self, element, startTime, endTime=None):
        if endTime == None:
            return False
        result = False
        indexArray = self.getBinaryDecomposition(startTime, endTime)
        for i in range(len(indexArray)):
            index = indexArray[i]
            if self.bfArray.get(index - 1).queryString(element):
                if i == 0 and index > len(self.bfArray) / 2 and not self.b0.queryString(element, startTime, startTime + self.g - startTime / self.g - 1):
                    continue          
                elif i == len(indexArray) - 1 and index > len(self.bfArray) / 2 and not self.b0.queryString(element, endTime - endTime / self.g, endTime):
                    continue
                result = True
                break
        return result
        

        
    def insert(self, element, timestamp):
        result = True
        index = 1
        start = 0
        end = self.maxT
        for i in range(0, self.levelNum - self.gLevel + 1):
            bf = self.bfArray[index - 1]
            if None != bf:
                bf.insert(element)
            mid = (start + end) / 2
            mid = int(mid)
                
            if mid < timestamp:
                start = mid + 1
                index = index * 2 + 1
                
            else:
                end = mid
                index = index * 2
            i += 1
        self.b0.insert(element, timestamp)
        return result

    def query(element, timestamp):
        return False

    def query(self, element, startTime, endTime):
        result = False
        indexArray = self.getBinaryDecomposition(startTime, endTime)

        for i in range(0, len(indexArray)):
            index = int(indexArray[i])
            #print(indexArray[i])
            bf = self.bfArray[index - 1]
            if  None == bf:
                result = True
                break
            elif bf.query(element):
                if i == 0 and index > len(self.bfArray) / 2 and not self.b0.query(element, startTime, startTime + self.g - startTime % self.g - 1):
                    continue
                elif i == len(indexArray) - 1 and index > len(self.bfArray) / 2 and not self.b0.query(element, endTime - endTime % self.g, endTime):
                    continue
                result = True
                break
        return result
    
    def getBinaryDecomposition(self, start, end):
        results = []
        #for i in range(start, end):
        i = start
        while i <= end:
            level = BinaryUtil2.getBinaryLevel(i, end)
            #print("level = "+ str(level))
            index = np.left_shift(1, self.levelNum - level) + int(i / CommonConstants.g[level-1])
            #index = (1 << (self.levelNum - level)) + i / CommonConstants.g[level - 1]
            #print("index value: " + str(index))
            #print("bf array = "+str())
            bf = len(self.bfArray)

            while (index > bf):
                index = index / 2
                index = int(index)
            
            results.append(index)
            i = i + (np.left_shift(1, level - 1))  
        #print(results)
        return results
    
    
    
    def getBfArray(self):
        return self.bfArray
    
    def getB0(self):
        return self.b0
    
    def getLevelNum(self):
        return self.levelNum
    
    def getLevelNum(self, maxT):
        result = 0
        for i in range(0, len(CommonConstants.g)):
            if (maxT + 1) <= CommonConstants.g[i]:
                result = i + 1
                break
        return result
    
    def getG(self):
        return self.g
    
    def getMaxT(self):
        return self.maxT
    
    def getTotalBitNum(self):
        return self.totalBitNum

def main():
        element = "guo".encode()
        b1 = Beta1(10000, 4, 1)
        b1.insert(element, 4)
        print(b1.query(element, 2, 5))
        print(b1.query(element, 2, 3))
        print(b1.query("jin".encode(), 1, 6))
        print(b1.getLevelNum(3))
        print("============")
        list1 = b1.getBinaryDecomposition(1, 4)
        for i in range(0, len(list1)):
            print(list1[i])         
        print(b1.getBinaryDecomposition(0, 0))
        
        
if __name__ == "__main__":
    main()





